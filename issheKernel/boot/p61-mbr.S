;主引导程序
;--------------------------------------------------------------------------
SECTION MBR vstart=0x7c00
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov fs, ax
    mov sp, 0x7c00

;清屏利用0x06号中断功能,上卷全部行，即可清屏
;--------------------------------------------------------------------------
;INT 0x10 功能号: 0x06 功能描述: 上卷窗口
;-------------------------------------------------------------------------
;输入：
; AH 功能号 = 0x06
; AL = 上卷的行数(如果为0，上卷全部)
; BH = 上卷行的属性
; (CL, CH) = 窗口左上角的(X, Y)位置
; (DL, DH) = 窗口右下角的(X, Y)位置
; 无返回值
    mov     ax, 0x600
    mov     bx, 0x700
    mov     cx, 0           ; 左上角(0, 0)
    mov     dx, 0x184f      ; 右下角(80, 25)
                            ; VGA文本模式，一行最多容纳80个字符，25行。
                            ; 下标从0开始，所以0x18 = 24， 0x4f = 79
    int     0x10            ; int 0x10

; 下面三行代码获取光标的位置
; .get_cursor获取当前光标位置，在光标位置处打印字符
    mov ah, 3               ; 输入: 3号子功能是获取光标位置, 需要存入ah寄存器
    mov bh, 0               ; bh寄存器存储的是待获取光标的页号

    int 0x10                ; 输出：ch = 光标开始行； cl = 光标结束行
                            ; dh = 光标所在行, dl = 光标所在列

; 打印字符串
; 还是10h中断，不过这次调用13号子功能
    mov ax, message
    mov bp, ax              ; es:bp为串首地址, es此时同cs一致, 开头已经为sreg初始化

; 光标位置要用到dx寄存器中的内容，cx中的光标位置可忽略
    mov cx, 5               ; cx 为串长度, 不包括结束符0的字符个数
    mov ax, 0x1301          ; 子功能号13, 存入ah寄存器
                            ; al 设置写字符方式，al = 01：显示字符串，光标跟随移动
    mov bx, 0x2             ; bh 存储要显示的也好，此处是第0页
                            ; bl 中是字符属性，属性黑底绿字(bl = 02h)
    int 0x10                ; 执行中断

; 打印字符串结束
    jmp $                   ; 使程序悬停在此
    message db "1 MBR"
    times 510-($-$$) db 0
    db 0x55, 0xaa
